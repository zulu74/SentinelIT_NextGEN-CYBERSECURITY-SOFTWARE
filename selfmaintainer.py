import os
import hashlib
import shutil
import requests
import zipfile
import time
from datetime import datetime

# Define essential modules and their hashes (can be auto-generated by another module)
ESSENTIAL_MODULES = {
    "siemcore.py": "auto",
    "packetshield.py": "auto",
    "iamwatch.py": "auto",
    "cloudwatch.py": "auto",
    "phantomstaff.py": "auto",
    "usbwatch.py": "auto",
    "policyengine.py": "auto",
    "kernelwatch.py": "auto",
    "memorywatch.py": "auto",
    "patchcheckv2.py": "auto"
}

# Remote update repo URL (could also be a local path or LAN server)
UPDATE_SOURCE = "https://your-secure-server.com/sentinelit/modules/"

# Logs
LOG_FILE = "sentinelit_selfmaintainer.log"

def log_action(msg):
    with open(LOG_FILE, "a") as f:
        f.write(f"[{datetime.now()}] {msg}\n")

def get_sha256(filename):
    if not os.path.exists(filename):
        return None
    h = hashlib.sha256()
    with open(filename, 'rb') as f:
        while chunk := f.read(4096):
            h.update(chunk)
    return h.hexdigest()

def download_and_replace(module):
    try:
        url = f"{UPDATE_SOURCE}{module}"
        r = requests.get(url, timeout=10)
        if r.status_code == 200:
            with open(f"{module}.tmp", "wb") as f:
                f.write(r.content)
            os.replace(f"{module}.tmp", module)
            log_action(f"{module} updated successfully from remote source.")
            return True
        else:
            log_action(f"Failed to download {module}: Status {r.status_code}")
    except Exception as e:
        log_action(f"Download error for {module}: {e}")
    return False

def self_heal_and_update():
    log_action("Starting self-maintenance check...")
    for module, expected_hash in ESSENTIAL_MODULES.items():
        current_hash = get_sha256(module)
        if not current_hash:
            log_action(f"{module} is missing. Attempting to restore...")
            download_and_replace(module)
        elif expected_hash != "auto" and current_hash != expected_hash:
            log_action(f"{module} hash mismatch. Attempting repair...")
            download_and_replace(module)
        else:
            log_action(f"{module} is OK.")
    log_action("Self-maintenance check completed.\n")

def auto_patch():
    from patchcheckv2 import run_patch_audit
    run_patch_audit()
    log_action("Patch check run via patchcheckv2.")

# You can schedule this via task scheduler or loop
if __name__ == "__main__":
    self_heal_and_update()
    auto_patch()
