<!DOCTYPE html>
<html lang="en">
<head>
┬а ┬а <meta charset="UTF-8">
┬а ┬а <meta name="viewport" content="width=device-width, initial-scale=1.0">
┬а ┬а <title>SentinelIT - Revolutionary 3D Network Universe</title>
┬а ┬а <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
┬а ┬а <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
┬а ┬а <style>
┬а ┬а ┬а ┬а * {
┬а ┬а ┬а ┬а ┬а ┬а margin: 0;
┬а ┬а ┬а ┬а ┬а ┬а padding: 0;
┬а ┬а ┬а ┬а ┬а ┬а box-sizing: border-box;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а body {
┬а ┬а ┬а ┬а ┬а ┬а background: radial-gradient(ellipse at center, #0a0a0a 0%, #000 70%);
┬а ┬а ┬а ┬а ┬а ┬а overflow: hidden;
┬а ┬а ┬а ┬а ┬а ┬а font-family: 'Courier New', monospace;
┬а ┬а ┬а ┬а ┬а ┬а color: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а cursor: none;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а #canvas-container {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 0;
┬а ┬а ┬а ┬а ┬а ┬а left: 0;
┬а ┬а ┬а ┬а ┬а ┬а width: 100vw;
┬а ┬а ┬а ┬а ┬а ┬а height: 100vh;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .hud {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 20px;
┬а ┬а ┬а ┬а ┬а ┬а left: 20px;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1000;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 0, 0, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 15px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 20px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(15px);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
┬а ┬а ┬а ┬а ┬а ┬а animation: hologram-shimmer 3s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes hologram-shimmer {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% { box-shadow: 0 0 30px rgba(0, 255, 65, 0.4); }
┬а ┬а ┬а ┬а ┬а ┬а 50% { box-shadow: 0 0 50px rgba(0, 255, 65, 0.8); }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .hud h1 {
┬а ┬а ┬а ┬а ┬а ┬а color: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а font-size: 28px;
┬а ┬а ┬а ┬а ┬а ┬а margin-bottom: 15px;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 15px rgba(0, 255, 65, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а animation: text-glow 2s ease-in-out infinite alternate;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes text-glow {
┬а ┬а ┬а ┬а ┬а ┬а from { text-shadow: 0 0 15px rgba(0, 255, 65, 0.8); }
┬а ┬а ┬а ┬а ┬а ┬а to { text-shadow: 0 0 25px rgba(0, 255, 65, 1), 0 0 35px rgba(0, 255, 65, 0.6); }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .hud-stats {
┬а ┬а ┬а ┬а ┬а ┬а display: grid;
┬а ┬а ┬а ┬а ┬а ┬а grid-template-columns: repeat(2, 1fr);
┬а ┬а ┬а ┬а ┬а ┬а gap: 12px;
┬а ┬а ┬а ┬а ┬а ┬а margin-top: 20px;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .stat-item {
┬а ┬а ┬а ┬а ┬а ┬а text-align: center;
┬а ┬а ┬а ┬а ┬а ┬а padding: 12px;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 255, 65, 0.1);
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 8px;
┬а ┬а ┬а ┬а ┬а ┬а border: 1px solid rgba(0, 255, 65, 0.5);
┬а ┬а ┬а ┬а ┬а ┬а transition: all 0.3s ease;
┬а ┬а ┬а ┬а ┬а ┬а animation: stat-pulse 4s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes stat-pulse {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% { transform: scale(1); }
┬а ┬а ┬а ┬а ┬а ┬а 50% { transform: scale(1.05); }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .stat-value {
┬а ┬а ┬а ┬а ┬а ┬а font-size: 24px;
┬а ┬а ┬а ┬а ┬а ┬а font-weight: bold;
┬а ┬а ┬а ┬а ┬а ┬а color: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 10px rgba(0, 255, 65, 0.8);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .stat-label {
┬а ┬а ┬а ┬а ┬а ┬а font-size: 12px;
┬а ┬а ┬а ┬а ┬а ┬а color: #888;
┬а ┬а ┬а ┬а ┬а ┬а margin-top: 5px;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .controls {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а bottom: 20px;
┬а ┬а ┬а ┬а ┬а ┬а left: 20px;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1000;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 0, 0, 0.9);
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 15px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 20px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(15px);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 30px rgba(0, 255, 65, 0.4);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .control-button {
┬а ┬а ┬а ┬а ┬а ┬а background: linear-gradient(45deg, rgba(0, 255, 65, 0.2), rgba(0, 255, 65, 0.1));
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а color: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а padding: 12px 20px;
┬а ┬а ┬а ┬а ┬а ┬а margin: 8px;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 8px;
┬а ┬а ┬а ┬а ┬а ┬а cursor: pointer;
┬а ┬а ┬а ┬а ┬а ┬а transition: all 0.3s ease;
┬а ┬а ┬а ┬а ┬а ┬а font-family: 'Courier New', monospace;
┬а ┬а ┬а ┬а ┬а ┬а font-weight: bold;
┬а ┬а ┬а ┬а ┬а ┬а text-transform: uppercase;
┬а ┬а ┬а ┬а ┬а ┬а position: relative;
┬а ┬а ┬а ┬а ┬а ┬а overflow: hidden;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .control-button::before {
┬а ┬а ┬а ┬а ┬а ┬а content: '';
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 0;
┬а ┬а ┬а ┬а ┬а ┬а left: -100%;
┬а ┬а ┬а ┬а ┬а ┬а width: 100%;
┬а ┬а ┬а ┬а ┬а ┬а height: 100%;
┬а ┬а ┬а ┬а ┬а ┬а background: linear-gradient(90deg, transparent, rgba(0, 255, 65, 0.4), transparent);
┬а ┬а ┬а ┬а ┬а ┬а transition: left 0.5s;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .control-button:hover::before {
┬а ┬а ┬а ┬а ┬а ┬а left: 100%;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .control-button:hover {
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 255, 65, 0.3);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
┬а ┬а ┬а ┬а ┬а ┬а transform: translateY(-2px);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .threat-alert {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 20px;
┬а ┬а ┬а ┬а ┬а ┬а right: 20px;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1000;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(255, 0, 0, 0.9);
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #ff4444;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 15px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 20px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(15px);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
┬а ┬а ┬а ┬а ┬а ┬а animation: critical-alert 1s infinite;
┬а ┬а ┬а ┬а ┬а ┬а max-width: 320px;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes critical-alert {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% {┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 1;┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transform: scale(1) rotate(0deg);┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 30px rgba(255, 68, 68, 0.6);
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а 25% {┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transform: scale(1.02) rotate(0.5deg);┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 40px rgba(255, 68, 68, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а 75% {┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transform: scale(1.02) rotate(-0.5deg);┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 40px rgba(255, 68, 68, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .threat-alert h3 {
┬а ┬а ┬а ┬а ┬а ┬а color: #fff;
┬а ┬а ┬а ┬а ┬а ┬а margin-bottom: 15px;
┬а ┬а ┬а ┬а ┬а ┬а font-size: 18px;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .loading-screen {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 0;
┬а ┬а ┬а ┬а ┬а ┬а left: 0;
┬а ┬а ┬а ┬а ┬а ┬а width: 100vw;
┬а ┬а ┬а ┬а ┬а ┬а height: 100vh;
┬а ┬а ┬а ┬а ┬а ┬а background: linear-gradient(45deg, #000 0%, #0a0a0a 50%, #000 100%);
┬а ┬а ┬а ┬а ┬а ┬а display: flex;
┬а ┬а ┬а ┬а ┬а ┬а flex-direction: column;
┬а ┬а ┬а ┬а ┬а ┬а justify-content: center;
┬а ┬а ┬а ┬а ┬а ┬а align-items: center;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 2000;
┬а ┬а ┬а ┬а ┬а ┬а transition: opacity 1s ease;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .loading-text {
┬а ┬а ┬а ┬а ┬а ┬а font-size: 32px;
┬а ┬а ┬а ┬а ┬а ┬а color: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а margin-bottom: 40px;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 20px rgba(0, 255, 65, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а animation: loading-pulse 2s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes loading-pulse {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% { transform: scale(1); opacity: 1; }
┬а ┬а ┬а ┬а ┬а ┬а 50% { transform: scale(1.05); opacity: 0.8; }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .loading-bar {
┬а ┬а ┬а ┬а ┬а ┬а width: 400px;
┬а ┬а ┬а ┬а ┬а ┬а height: 6px;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 255, 65, 0.2);
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 3px;
┬а ┬а ┬а ┬а ┬а ┬а overflow: hidden;
┬а ┬а ┬а ┬а ┬а ┬а border: 1px solid rgba(0, 255, 65, 0.5);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .loading-progress {
┬а ┬а ┬а ┬а ┬а ┬а height: 100%;
┬а ┬а ┬а ┬а ┬а ┬а background: linear-gradient(90deg, #00ff41, #00aa2a, #00ff41);
┬а ┬а ┬а ┬а ┬а ┬а background-size: 200% 100%;
┬а ┬а ┬а ┬а ┬а ┬а width: 0%;
┬а ┬а ┬а ┬а ┬а ┬а animation: loading 4s ease forwards, shimmer 2s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes loading {
┬а ┬а ┬а ┬а ┬а ┬а to { width: 100%; }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes shimmer {
┬а ┬а ┬а ┬а ┬а ┬а 0% { background-position: -200% 0; }
┬а ┬а ┬а ┬а ┬а ┬а 100% { background-position: 200% 0; }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .node-info {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 0, 0, 0.95);
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 12px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 20px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(15px);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 25px rgba(0, 255, 65, 0.5);
┬а ┬а ┬а ┬а ┬а ┬а pointer-events: none;
┬а ┬а ┬а ┬а ┬а ┬а opacity: 0;
┬а ┬а ┬а ┬а ┬а ┬а transition: all 0.3s ease;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1500;
┬а ┬а ┬а ┬а ┬а ┬а max-width: 300px;
┬а ┬а ┬а ┬а ┬а ┬а transform: scale(0.8);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .node-info.show {
┬а ┬а ┬а ┬а ┬а ┬а opacity: 1;
┬а ┬а ┬а ┬а ┬а ┬а transform: scale(1);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .fps-counter {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 20px;
┬а ┬а ┬а ┬а ┬а ┬а right: 360px;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1000;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 0, 0, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а border: 1px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 8px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 12px;
┬а ┬а ┬а ┬а ┬а ┬а font-size: 14px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(10px);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .ai-predictions {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а bottom: 20px;
┬а ┬а ┬а ┬а ┬а ┬а right: 20px;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1000;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(0, 0, 0, 0.9);
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #ffd700;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 15px;
┬а ┬а ┬а ┬а ┬а ┬а padding: 20px;
┬а ┬а ┬а ┬а ┬а ┬а backdrop-filter: blur(15px);
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 30px rgba(255, 215, 0, 0.4);
┬а ┬а ┬а ┬а ┬а ┬а max-width: 350px;
┬а ┬а ┬а ┬а ┬а ┬а animation: ai-glow 3s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes ai-glow {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% { box-shadow: 0 0 30px rgba(255, 215, 0, 0.4); }
┬а ┬а ┬а ┬а ┬а ┬а 50% { box-shadow: 0 0 40px rgba(255, 215, 0, 0.7); }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .ai-predictions h3 {
┬а ┬а ┬а ┬а ┬а ┬а color: #ffd700;
┬а ┬а ┬а ┬а ┬а ┬а margin-bottom: 15px;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 15px rgba(255, 215, 0, 0.8);
┬а ┬а ┬а ┬а ┬а ┬а font-size: 18px;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .prediction-item {
┬а ┬а ┬а ┬а ┬а ┬а margin: 10px 0;
┬а ┬а ┬а ┬а ┬а ┬а padding: 8px 12px;
┬а ┬а ┬а ┬а ┬а ┬а background: rgba(255, 215, 0, 0.1);
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 6px;
┬а ┬а ┬а ┬а ┬а ┬а font-size: 13px;
┬а ┬а ┬а ┬а ┬а ┬а border-left: 3px solid #ffd700;
┬а ┬а ┬а ┬а ┬а ┬а animation: prediction-slide 0.5s ease;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes prediction-slide {
┬а ┬а ┬а ┬а ┬а ┬а from { transform: translateX(-20px); opacity: 0; }
┬а ┬а ┬а ┬а ┬а ┬а to { transform: translateX(0); opacity: 1; }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .custom-cursor {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а width: 20px;
┬а ┬а ┬а ┬а ┬а ┬а height: 20px;
┬а ┬а ┬а ┬а ┬а ┬а border: 2px solid #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 50%;
┬а ┬а ┬а ┬а ┬а ┬а pointer-events: none;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 3000;
┬а ┬а ┬а ┬а ┬а ┬а transition: all 0.1s ease;
┬а ┬а ┬а ┬а ┬а ┬а box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .custom-cursor::after {
┬а ┬а ┬а ┬а ┬а ┬а content: '';
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 50%;
┬а ┬а ┬а ┬а ┬а ┬а left: 50%;
┬а ┬а ┬а ┬а ┬а ┬а transform: translate(-50%, -50%);
┬а ┬а ┬а ┬а ┬а ┬а width: 4px;
┬а ┬а ┬а ┬а ┬а ┬а height: 4px;
┬а ┬а ┬а ┬а ┬а ┬а background: #00ff41;
┬а ┬а ┬а ┬а ┬а ┬а border-radius: 50%;
┬а ┬а ┬а ┬а ┬а ┬а animation: cursor-pulse 2s ease-in-out infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes cursor-pulse {
┬а ┬а ┬а ┬а ┬а ┬а 0%, 100% { transform: translate(-50%, -50%) scale(1); }
┬а ┬а ┬а ┬а ┬а ┬а 50% { transform: translate(-50%, -50%) scale(1.5); }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а .universe-title {
┬а ┬а ┬а ┬а ┬а ┬а position: absolute;
┬а ┬а ┬а ┬а ┬а ┬а top: 50%;
┬а ┬а ┬а ┬а ┬а ┬а left: 50%;
┬а ┬а ┬а ┬а ┬а ┬а transform: translate(-50%, -50%);
┬а ┬а ┬а ┬а ┬а ┬а font-size: 72px;
┬а ┬а ┬а ┬а ┬а ┬а color: rgba(0, 255, 65, 0.1);
┬а ┬а ┬а ┬а ┬а ┬а font-weight: bold;
┬а ┬а ┬а ┬а ┬а ┬а text-shadow: 0 0 50px rgba(0, 255, 65, 0.3);
┬а ┬а ┬а ┬а ┬а ┬а pointer-events: none;
┬а ┬а ┬а ┬а ┬а ┬а z-index: 1;
┬а ┬а ┬а ┬а ┬а ┬а animation: universe-rotate 20s linear infinite;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а @keyframes universe-rotate {
┬а ┬а ┬а ┬а ┬а ┬а from { transform: translate(-50%, -50%) rotate(0deg); }
┬а ┬а ┬а ┬а ┬а ┬а to { transform: translate(-50%, -50%) rotate(360deg); }
┬а ┬а ┬а ┬а }

/* New CSS for the team collaboration button */
.team-collaboration-btn {
    position: absolute;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
}
.btn {
    text-decoration: none;
    padding: 12px 20px;
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-weight: bold;
    text-transform: uppercase;
    transition: all 0.3s ease;
    cursor: pointer;
}
.btn-outline-info {
    border: 2px solid #00ffff;
    color: #00ffff;
    background: transparent;
    box-shadow: 0 0 10px rgba(0, 255, 255, 0.4);
}
.btn-outline-info:hover {
    background: rgba(0, 255, 255, 0.2);
    box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
}

┬а ┬а </style>
</head>
<body>
┬а ┬а ┬а ┬а <div class="custom-cursor" id="customCursor"></div>

┬а ┬а ┬а ┬а <div class="loading-screen" id="loadingScreen">
┬а ┬а ┬а ┬а <div class="loading-text">­ЪЏА№ИЈ INITIALIZING SENTINELIT QUANTUM NETWORK</div>
┬а ┬а ┬а ┬а <div class="loading-bar">
┬а ┬а ┬а ┬а ┬а ┬а <div class="loading-progress"></div>
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div style="margin-top: 30px; color: #888; font-size: 16px; text-align: center;">
┬а ┬а ┬а ┬а ┬а ┬а <div>РџА Activating quantum sensors...</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а<div>­Ъїљ Mapping network topology...</div>
┬а ┬а ┬а ┬а ┬а ┬а <div>­ЪДа Initializing AI threat prediction...</div>
┬а ┬а ┬а ┬а ┬а ┬а <div>Рюе Ready to revolutionize cybersecurity</div>
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div class="universe-title">SENTINELIT</div>

┬а ┬а ┬а ┬а <div class="hud">
┬а ┬а ┬а ┬а <h1>­Ъїї NETWORK UNIVERSE</h1>
┬а ┬а ┬а ┬а <div style="color: #00ff41; font-weight: bold;">Status: QUANTUM MONITORING ACTIVE</div>
┬а ┬а ┬а ┬а <div>Nodes Tracked: <span id="nodeCount" style="color: #00ff41; font-weight: bold;">0</span></div>
┬а ┬а ┬а ┬а <div>Threats Detected: <span style="color: #ff4444; font-weight: bold;" id="threatCount">0</span></div>
┬а ┬а ┬а ┬а <div>AI Confidence: <span style="color: #ffd700; font-weight: bold;" id="aiConfidence">98.7%</span></div>
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а <div class="hud-stats">
┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-item">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-value" id="packetsPerSec">2.4M</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-label">Packets/sec</div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-item">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-value" id="networkLoad">67%</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-label">Network Load</div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-item">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-value" id="responseTime">0.8ms</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-label">Response Time</div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-item">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-value" id="uptime">99.97%</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div class="stat-label">System Uptime</div>
┬а ┬а ┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div class="fps-counter">
┬а ┬а ┬а ┬а <div style="color: #00ff41; font-weight: bold;">PERFORMANCE</div>
┬а ┬а ┬а ┬а <div>FPS: <span id="fps" style="color: #00ff41;">60</span></div>
┬а ┬а ┬а ┬а <div>Render: <span id="renderTime">16ms</span></div>
┬а ┬а ┬а ┬а <div>Nodes: <span id="renderedNodes">0</span></div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div class="threat-alert" id="threatAlert" style="display: none;">
┬а ┬а ┬а ┬а <h3>Рџа№ИЈ CRITICAL THREAT DETECTED</h3>
┬а ┬а ┬а ┬а <div style="margin: 10px 0;">
┬а ┬а ┬а ┬а ┬а ┬а <div>­Ъј» <strong>Advanced Persistent Threat</strong></div>
┬а ┬а ┬а ┬а ┬а ┬а <div>­ЪЊЇ Node: <span id="threatNode">UNKNOWN</span></div>
┬а ┬а ┬а ┬а ┬а ┬а <div>­ЪћЦ Risk Level: <span style="color: #ffff00;">EXTREME</span></div>
┬а ┬а ┬а ┬а ┬а ┬а <div>РЈ▒№ИЈ Detected: <span id="threatTime">Now</span></div>
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div style="margin-top: 15px;">
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="isolateNode()" style="margin: 5px; padding: 8px 15px;">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ­ЪЏА№ИЈ ISOLATE
┬а ┬а ┬а ┬а ┬а ┬а </button>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="analyzeNode()" style="margin: 5px; padding: 8px 15px;">
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ­ЪћЇ ANALYZE
┬а ┬а ┬а ┬а ┬а ┬а </button>
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div class="ai-predictions">
┬а ┬а ┬а ┬а <h3>­ЪДа AI QUANTUM PREDICTIONS</h3>
┬а ┬а ┬а ┬а <div class="prediction-item" id="prediction1">
┬а ┬а ┬а ┬а ┬а ┬а ­ЪЊі Analyzing network patterns...
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div class="prediction-item" id="prediction2">
┬а ┬а ┬а ┬а ┬а ┬а ­Ъј» Scanning for anomalies...
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div class="prediction-item" id="prediction3">
┬а ┬а ┬а ┬а ┬а ┬а РџА Monitoring data flows...</div>
┬а ┬а ┬а ┬а <div class="prediction-item" id="prediction4">
┬а ┬а ┬а ┬а ┬а ┬а ­Ъћ« Quantum algorithms initializing...
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div class="controls">
┬а ┬а ┬а ┬а <div style="margin-bottom: 15px; color: #00ff41; font-weight: bold; font-size: 16px;">
┬а ┬а ┬а ┬а ┬а ┬а ­Ъј« UNIVERSE CONTROLS
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="resetView()">­ЪЈа Reset View</button>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="toggleThreats()" id="threatBtn">Рџа№ИЈ Show Threats</button>
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="toggleTraffic()" id="trafficBtn">­ЪЊі Data Flows</button>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="toggleAI()" id="aiBtn">­ЪДа AI Mode</button>
┬а ┬а ┬а ┬а </div>
┬а ┬а ┬а ┬а <div>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="emergencyMode()">­Ъџе Emergency</button>
┬а ┬а ┬а ┬а ┬а ┬а <button class="control-button" onclick="quantumScan()">РџЏ№ИЈ Quantum Scan</button>
┬а ┬а ┬а ┬а </div>
┬а ┬а </div>

    <div class="team-collaboration-btn">
        <a href="{{ url_for('team_collaboration') }}" class="btn btn-outline-info">
            ­ЪЉЦ Team Collaboration Universe
        </a>
    </div>

┬а ┬а ┬а ┬а <div class="node-info" id="nodeInfo">
┬а ┬а ┬а ┬а <h4 id="nodeTitle" style="color: #00ff41; margin-bottom: 10px;">Node Information</h4>
┬а ┬а ┬а ┬а <div id="nodeDetails" style="color: #ccc;"></div>
┬а ┬а </div>

┬а ┬а ┬а ┬а <div id="canvas-container"></div>

┬а ┬а <script>
┬а ┬а ┬а ┬а // Global variables
┬а ┬а ┬а ┬а let scene, camera, renderer;
┬а ┬а ┬а ┬а let networkNodes = [];
┬а ┬а ┬а ┬а let connections = [];
┬а ┬а ┬а ┬а let threatNodes = [];
┬а ┬а ┬а ┬а let dataStreams = [];
┬а ┬а ┬а ┬а let stars = [];
┬а ┬а ┬а ┬а let animationId;
┬а ┬а ┬а ┬а let mouseX = 0, mouseY = 0;
┬а ┬а ┬а ┬а let showThreats = true;
┬а ┬а ┬а ┬а let showTraffic = true;
┬а ┬а ┬а ┬а let aiMode = false;
┬а ┬а ┬а ┬а let emergencyActive = false;
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Performance tracking
┬а ┬а ┬а ┬а let lastTime = performance.now();
┬а ┬а ┬а ┬а let frameCount = 0;
┬а ┬а ┬а ┬а let fps = 0;

┬а ┬а ┬а ┬а // Mouse tracking for custom cursor
┬а ┬а ┬а ┬а document.addEventListener('mousemove', (e) => {
┬а ┬а ┬а ┬а ┬а ┬а mouseX = (e.clientX / window.innerWidth) * 2 - 1;
┬а ┬а ┬а ┬а ┬а ┬а mouseY = -(e.clientY / window.innerHeight) * 2 + 1;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а const cursor = document.getElementById('customCursor');
┬а ┬а ┬а ┬а ┬а ┬а cursor.style.left = e.clientX + 'px';
┬а ┬а ┬а ┬а ┬а ┬а cursor.style.top = e.clientY + 'px';
┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а // Initialize the 3D universe
┬а ┬а ┬а ┬а function initUniverse() {
┬а ┬а ┬а ┬а ┬а ┬а // Scene setup
┬а ┬а ┬а ┬а ┬а ┬а scene = new THREE.Scene();
┬а ┬а ┬а ┬а ┬а ┬а scene.fog = new THREE.FogExp2(0x000000, 0.003);

┬а ┬а ┬а ┬а ┬а ┬а // Camera setup
┬а ┬а ┬а ┬а ┬а ┬а camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 3000);
┬а ┬а ┬а ┬а ┬а ┬а camera.position.set(0, 200, 400);

┬а ┬а ┬а ┬а ┬а ┬а // Renderer setup
┬а ┬а ┬а ┬а ┬а ┬а renderer = new THREE.WebGLRenderer({┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а antialias: true,┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alpha: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а powerPreference: "high-performance"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а renderer.setSize(window.innerWidth, window.innerHeight);
┬а ┬а ┬а ┬а ┬а ┬а renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
┬а ┬а ┬а ┬а ┬а ┬а renderer.setClearColor(0x000000, 0);
┬а ┬а ┬а ┬а ┬а ┬а renderer.shadowMap.enabled = true;
┬а ┬а ┬а ┬а ┬а ┬а renderer.shadowMap.type = THREE.PCFSoftShadowMap;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('canvas-container').appendChild(renderer.domElement);

┬а ┬а ┬а ┬а ┬а ┬а // Lighting setup
┬а ┬а ┬а ┬а ┬а ┬а const ambientLight = new THREE.AmbientLight(0x002200, 0.3);
┬а ┬а ┬а ┬а ┬а ┬а scene.add(ambientLight);

┬а ┬а ┬а ┬а ┬а ┬а const mainLight = new THREE.DirectionalLight(0x00ff41, 1);
┬а ┬а ┬а ┬а ┬а ┬а mainLight.position.set(200, 200, 100);
┬а ┬а ┬а ┬а ┬а ┬а mainLight.castShadow = true;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.near = 1;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.far = 1000;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.left = -500;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.right = 500;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.top = 500;
┬а ┬а ┬а ┬а ┬а ┬а mainLight.shadow.camera.bottom = -500;
┬а ┬а ┬а ┬а ┬а ┬а scene.add(mainLight);

┬а ┬а ┬а ┬а ┬а ┬а // Point lights for atmosphere
┬а ┬а ┬а ┬а ┬а ┬а const pointLight1 = new THREE.PointLight(0x0088ff, 0.8, 300);
┬а ┬а ┬а ┬а ┬а ┬а pointLight1.position.set(-100, 100, 200);
┬а ┬а ┬а ┬а ┬а ┬а scene.add(pointLight1);

┬а ┬а ┬а ┬а ┬а ┬а const pointLight2 = new THREE.PointLight(0xff4400, 0.6, 300);
┬а ┬а ┬а ┬а ┬а ┬а pointLight2.position.set(100, -100, -200);
┬а ┬а ┬а ┬а ┬а ┬а scene.add(pointLight2);

┬а ┬а ┬а ┬а ┬а ┬а // Create universe components
┬а ┬а ┬а ┬а ┬а ┬а createStarfield();
┬а ┬а ┬а ┬а ┬а ┬а createNetworkNodes();
┬а ┬а ┬а ┬а ┬а ┬а createConnections();
┬а ┬а ┬а ┬а ┬а ┬а createThreatNodes();
┬а ┬а ┬а ┬а ┬а ┬а createDataStreams();

┬а ┬а ┬а ┬а ┬а ┬а // Setup interactions
┬а ┬а ┬а ┬а ┬а ┬а setupMouseInteraction();

┬а ┬а ┬а ┬а ┬а ┬а // Start animation loop
┬а ┬а ┬а ┬а ┬а ┬а animate();

┬а ┬а ┬а ┬а ┬а ┬а // Update UI with actual counts
┬а ┬а ┬а ┬а ┬а ┬а updateNodeCount();
┬а ┬а ┬а ┬а ┬а ┬а startAIPredictions();

┬а ┬а ┬а ┬а ┬а ┬а // Hide loading screen after initialization
┬а ┬а ┬а ┬а ┬а ┬а setTimeout(() => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('loadingScreen').style.opacity = '0';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а setTimeout(() => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('loadingScreen').style.display = 'none';
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а showWelcomeAnimation();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }, 1000);
┬а ┬а ┬а ┬а ┬а ┬а }, 4000);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Create beautiful starfield background
┬а ┬а ┬а ┬а function createStarfield() {
┬а ┬а ┬а ┬а ┬а ┬а const starGeometry = new THREE.BufferGeometry();
┬а ┬а ┬а ┬а ┬а ┬а const starCount = 2000;
┬а ┬а ┬а ┬а ┬а ┬а const positions = new Float32Array(starCount * 3);
┬а ┬а ┬а ┬а ┬а ┬а const colors = new Float32Array(starCount * 3);

┬а ┬а ┬а ┬а ┬а ┬а for (let i = 0; i < starCount * 3; i += 3) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а positions[i] = (Math.random() - 0.5) * 4000;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а positions[i + 1] = (Math.random() - 0.5) * 4000;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а positions[i + 2] = (Math.random() - 0.5) * 4000;

┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Vary star colors
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const color = new THREE.Color();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а color.setHSL(Math.random() * 0.3 + 0.5, 0.7, Math.random() * 0.5 + 0.5);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а colors[i] = color.r;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а colors[i + 1] = color.g;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а colors[i + 2] = color.b;
┬а ┬а ┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а ┬а ┬а starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
┬а ┬а ┬а ┬а ┬а ┬а starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

┬а ┬а ┬а ┬а ┬а ┬а const starMaterial = new THREE.PointsMaterial({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а size: 2,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а vertexColors: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transparent: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 0.8
┬а ┬а ┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а ┬а ┬а const starField = new THREE.Points(starGeometry, starMaterial);
┬а ┬а ┬а ┬а ┬а ┬а scene.add(starField);
┬а ┬а ┬а ┬а ┬а ┬а stars.push(starField);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Create network nodes with different types
┬а ┬а ┬а ┬а function createNetworkNodes() {
┬а ┬а ┬а ┬а ┬а ┬а const nodeTypes = [
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а { type: 'server', color: 0x00ff41, size: 4, count: 8, shape: 'box' },
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а { type: 'workstation', color: 0x0088ff, size: 3, count: 25, shape: 'sphere' },
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а { type: 'mobile', color: 0xff8800, size: 2, count: 15, shape: 'tetrahedron' },
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а { type: 'iot', color: 0x8800ff, size: 1.5, count: 12, shape: 'octahedron' },
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а { type: 'router', color: 0xffff00, size: 3.5, count: 6, shape: 'cylinder' }
┬а ┬а ┬а ┬а ┬а ┬а ];

┬а ┬а ┬а ┬а ┬а ┬а nodeTypes.forEach(nodeType => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а for (let i = 0; i < nodeType.count; i++) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а let geometry;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а switch (nodeType.shape) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а case 'box':
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а geometry = new THREE.BoxGeometry(nodeType.size, nodeType.size, nodeType.size);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а break;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а case 'tetrahedron':
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а geometry = new THREE.TetrahedronGeometry(nodeType.size);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а break;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а case 'octahedron':
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а geometry = new THREE.OctahedronGeometry(nodeType.size);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а break;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а case 'cylinder':
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а geometry = new THREE.CylinderGeometry(nodeType.size, nodeType.size, nodeType.size * 1.5);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а break;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а default:
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а geometry = new THREE.SphereGeometry(nodeType.size, 16, 16);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const material = new THREE.MeshPhongMaterial({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а color: nodeType.color,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transparent: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 0.8,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а emissive: nodeType.color,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а emissiveIntensity: 0.2
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const node = new THREE.Mesh(geometry, material);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Position nodes in 3D space
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const radius = 150 + Math.random() * 200;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const theta = Math.random() * Math.PI * 2;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const phi = Math.random() * Math.PI;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.position.x = radius * Math.sin(phi) * Math.cos(theta);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.position.y = radius * Math.sin(phi) * Math.sin(theta);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.position.z = radius * Math.cos(phi);

┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Add rotation animation
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.userData = {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а type: nodeType.type,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а originalColor: nodeType.color,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а rotationSpeed: Math.random() * 0.02 + 0.01,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а pulseSpeed: Math.random() * 0.05 + 0.02,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а id: `${nodeType.type}-${i}`,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а status: Math.random() > 0.1 ? 'healthy' : 'warning'
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а };

┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а scene.add(node);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а networkNodes.push(node);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Create connections between nodes
┬а ┬а ┬а ┬а function createConnections() {
┬а ┬а ┬а ┬а ┬а ┬а const connectionCount = Math.floor(networkNodes.length * 1.5);
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а for (let i = 0; i < connectionCount; i++) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const node1 = networkNodes[Math.floor(Math.random() * networkNodes.length)];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const node2 = networkNodes[Math.floor(Math.random() * networkNodes.length)];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (node1 !== node2) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const points = [node1.position, node2.position];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const geometry = new THREE.BufferGeometry().setFromPoints(points);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const material = new THREE.LineBasicMaterial({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а color: 0x004400,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transparent: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 0.3
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const line = new THREE.Line(geometry, material);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а line.userData = {┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node1: node1,┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node2: node2,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а traffic: Math.random()
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а scene.add(line);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а connections.push(line);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Create threat indicators
┬а ┬а ┬а ┬а function createThreatNodes() {
┬а ┬а ┬а ┬а ┬а ┬а const threatCount = 3;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а for (let i = 0; i < threatCount; i++) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const geometry = new THREE.SphereGeometry(6, 16, 16);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const material = new THREE.MeshPhongMaterial({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а color: 0xff0000,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transparent: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 0.7,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а emissive: 0xff0000,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а emissiveIntensity: 0.3
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const threat = new THREE.Mesh(geometry, material);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Position near random network nodes
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const targetNode = networkNodes[Math.floor(Math.random() * networkNodes.length)];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.copy(targetNode.position);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.x += (Math.random() - 0.5) * 20;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.y += (Math.random() - 0.5) * 20;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.z += (Math.random() - 0.5) * 20;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.userData = {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а type: 'threat',
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а severity: Math.random() > 0.5 ? 'critical' : 'high',
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а pulseSpeed: 0.1,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а targetNode: targetNode,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а id: `threat-${i}`
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а scene.add(threat);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threatNodes.push(threat);
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Create animated data streams
┬а ┬а ┬а ┬а function createDataStreams() {
┬а ┬а ┬а ┬а ┬а ┬а connections.forEach((connection, index) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (Math.random() > 0.7) { // 30% of connections have visible data streams
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const streamGeometry = new THREE.SphereGeometry(0.5, 8, 8);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const streamMaterial = new THREE.MeshBasicMaterial({
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а color: 0x00ffff,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а transparent: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а opacity: 0.8
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const stream = new THREE.Mesh(streamGeometry, streamMaterial);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.userData = {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а connection: connection,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а progress: Math.random(),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а speed: Math.random() * 0.02 + 0.01,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а direction: Math.random() > 0.5 ? 1 : -1
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а scene.add(stream);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а dataStreams.push(stream);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Setup mouse interaction
┬а ┬а ┬а ┬а function setupMouseInteraction() {
┬а ┬а ┬а ┬а ┬а ┬а const raycaster = new THREE.Raycaster();
┬а ┬а ┬а ┬а ┬а ┬а const mouse = new THREE.Vector2();
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а renderer.domElement.addEventListener('mousemove', (event) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а raycaster.setFromCamera(mouse, camera);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const intersects = raycaster.intersectObjects(networkNodes);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const nodeInfo = document.getElementById('nodeInfo');
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (intersects.length > 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const node = intersects[0].object;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а showNodeInfo(node, event.clientX, event.clientY);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а } else {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а hideNodeInfo();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а renderer.domElement.addEventListener('click', (event) => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а raycaster.setFromCamera(mouse, camera);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const intersects = raycaster.intersectObjects([...networkNodes, ...threatNodes]);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (intersects.length > 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const object = intersects[0].object;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а focusOnNode(object);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (object.userData.type === 'threat') {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а showThreatAlert(object);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Show node information
┬а ┬а ┬а ┬а function showNodeInfo(node, x, y) {
┬а ┬а ┬а ┬а ┬а ┬а const nodeInfo = document.getElementById('nodeInfo');
┬а ┬а ┬а ┬а ┬а ┬а const title = document.getElementById('nodeTitle');
┬а ┬а ┬а ┬а ┬а ┬а const details = document.getElementById('nodeDetails');
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а title.textContent = `${node.userData.type.toUpperCase()} - ${node.userData.id}`;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а const cpuUsage = Math.floor(Math.random() * 40) + 30;
┬а ┬а ┬а ┬а ┬а ┬а const memUsage = Math.floor(Math.random() * 30) + 40;
┬а ┬а ┬а ┬а ┬а ┬а const connections = Math.floor(Math.random() * 50) + 10;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а details.innerHTML = `
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>Status:</strong> <span style="color: ${node.userData.status === 'healthy' ? '#00ff41' : '#ffa500'}">${node.userData.status.toUpperCase()}</span></div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>CPU Usage:</strong> ${cpuUsage}%</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>Memory:</strong> ${memUsage}%</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>Connections:</strong> ${connections}</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>Last Scan:</strong> ${Math.floor(Math.random() * 60)} min ago</div>
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а <div style="margin: 8px 0;"><strong>Threats:</strong> <span style="color: #ff4444">${Math.floor(Math.random() * 3)}</span></div>
┬а ┬а ┬а ┬а ┬а ┬а `;
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а nodeInfo.style.left = (x + 20) + 'px';
┬а ┬а ┬а ┬а ┬а ┬а nodeInfo.style.top = (y - 50) + 'px';
┬а ┬а ┬а ┬а ┬а ┬а nodeInfo.classList.add('show');
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Hide node information
┬а ┬а ┬а ┬а function hideNodeInfo() {
┬а ┬а ┬а ┬а ┬а ┬а const nodeInfo = document.getElementById('nodeInfo');
┬а ┬а ┬а ┬а ┬а ┬а nodeInfo.classList.remove('show');
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Focus camera on specific node
┬а ┬а ┬а ┬а function focusOnNode(node) {
┬а ┬а ┬а ┬а ┬а ┬а const targetPosition = {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а x: node.position.x + 50,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: node.position.y + 30,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: node.position.z + 80
┬а ┬а ┬а ┬а ┬а ┬а };
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(camera.position, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 1.5,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а x: targetPosition.x,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: targetPosition.y,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: targetPosition.z,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power2.inOut"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(camera.rotation, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 1.5,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а x: Math.atan2(-targetPosition.y, Math.sqrt(targetPosition.x*targetPosition.x + targetPosition.z*targetPosition.z)),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: Math.atan2(targetPosition.x, targetPosition.z),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: 0,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power2.inOut"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Reset camera to initial position
┬а ┬а ┬а ┬а function resetView() {
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(camera.position, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 1.5,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а x: 0,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: 200,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: 400,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power2.inOut"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(camera.rotation, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 1.5,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а x: -Math.PI / 8,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: 0,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: 0,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power2.inOut"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Toggle visibility of threat nodes
┬а ┬а ┬а ┬а function toggleThreats() {
┬а ┬а ┬а ┬а ┬а ┬а showThreats = !showThreats;
┬а ┬а ┬а ┬а ┬а ┬а threatNodes.forEach(node => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.visible = showThreats;
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а const btn = document.getElementById('threatBtn');
┬а ┬а ┬а ┬а ┬а ┬а btn.textContent = showThreats ? 'Рџа№ИЈ Hide Threats' : 'Рџа№ИЈ Show Threats';
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Toggle visibility of data streams
┬а ┬а ┬а ┬а function toggleTraffic() {
┬а ┬а ┬а ┬а ┬а ┬а showTraffic = !showTraffic;
┬а ┬а ┬а ┬а ┬а ┬а dataStreams.forEach(stream => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.visible = showTraffic;
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а connections.forEach(line => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а line.material.color.setHex(showTraffic ? 0x00ff41 : 0x004400);
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а const btn = document.getElementById('trafficBtn');
┬а ┬а ┬а ┬а ┬а ┬а btn.textContent = showTraffic ? '­ЪЊі Hide Flows' : '­ЪЊі Show Flows';
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Toggle AI mode
┬а ┬а ┬а ┬а function toggleAI() {
┬а ┬а ┬а ┬а ┬а ┬а aiMode = !aiMode;
┬а ┬а ┬а ┬а ┬а ┬а const btn = document.getElementById('aiBtn');
┬а ┬а ┬а ┬а ┬а ┬а btn.textContent = aiMode ? '­ЪДа AI Mode: ON' : '­ЪДа AI Mode: OFF';
┬а ┬а ┬а ┬а ┬а ┬а const aiPredictions = document.querySelector('.ai-predictions');
┬а ┬а ┬а ┬а ┬а ┬а aiPredictions.style.display = aiMode ? 'block' : 'none';
┬а ┬а ┬а ┬а ┬а ┬а if (aiMode) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а startAIPredictions();
┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Trigger emergency mode
┬а ┬а ┬а ┬а function emergencyMode() {
┬а ┬а ┬а ┬а ┬а ┬а emergencyActive = true;
┬а ┬а ┬а ┬а ┬а ┬а document.body.style.background = 'radial-gradient(ellipse at center, #300000 0%, #000 70%)';
┬а ┬а ┬а ┬а ┬а ┬а document.body.style.color = '#ff4444';
┬а ┬а ┬а ┬а ┬а ┬а networkNodes.forEach(node => node.material.color.setHex(0xff0000));
┬а ┬а ┬а ┬а ┬а ┬а connections.forEach(line => line.material.color.setHex(0xff0000));
┬а ┬а ┬а ┬а ┬а ┬а alert('­Ъџе Emergency Protocol Initiated! Network Lockdown Activated.');
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Start quantum scan simulation
┬а ┬а ┬а ┬а function quantumScan() {
┬а ┬а ┬а ┬а ┬а ┬а alert('РџЏ№ИЈ Quantum Scan Initiated. This may take a moment...');
┬а ┬а ┬а ┬а ┬а ┬а // Simulate a scan effect
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(camera.position, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 3,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а z: camera.position.z - 200,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power1.inOut",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а yoyo: true,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а repeat: 1
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а gsap.to(scene.rotation, {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а duration: 3,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а y: "+=" + Math.PI * 2,
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ease: "power1.inOut"
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а setTimeout(() => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а alert('РюЁ Quantum Scan Complete. No new threats detected.');
┬а ┬а ┬а ┬а ┬а ┬а }, 3500);
┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Animate AI predictions
┬а ┬а ┬а ┬а function startAIPredictions() {
┬а ┬а ┬а ┬а ┬а ┬а const predictions = [
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­ЪЊі Analyzing network patterns...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­Ъј» Scanning for anomalies...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "РџА Monitoring data flows...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­Ъћ« Quantum algorithms initializing...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­ЪЊѕ Predicting DDoS attack vectors...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­ЪћЇ Identifying compromised nodes...",
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а "­ЪЏА№ИЈ Proposing firewall rule changes..."
┬а ┬а ┬а ┬а ┬а ┬а ];
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а let predictionIndex = 0;
┬а ┬а ┬а ┬а ┬а ┬а const predictionElements = [
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('prediction1'),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('prediction2'),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('prediction3'),
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('prediction4')
┬а ┬а ┬а ┬а ┬а ┬а ];
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а setInterval(() => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (!aiMode) return;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а predictionIndex = (predictionIndex + 1) % predictions.length;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const lastElement = predictionElements.pop();
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а lastElement.textContent = predictions[predictionIndex];
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а predictionElements.unshift(lastElement);
┬а ┬а ┬а ┬а ┬а ┬а }, 2000);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Update HUD stats
┬а ┬а ┬а ┬а function updateHUD() {
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('packetsPerSec').textContent = (Math.random() * 2 + 1).toFixed(1) + "M";
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('networkLoad').textContent = (Math.random() * 30 + 50).toFixed(0) + "%";
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('responseTime').textContent = (Math.random() * 0.5 + 0.3).toFixed(1) + "ms";
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('aiConfidence').textContent = (Math.random() * 5 + 95).toFixed(1) + "%";
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('nodeCount').textContent = networkNodes.length;
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('threatCount').textContent = threatNodes.length;
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Animate scene
┬а ┬а ┬а ┬а function animate() {
┬а ┬а ┬а ┬а ┬а ┬а animationId = requestAnimationFrame(animate);

┬а ┬а ┬а ┬а ┬а ┬а // Update FPS
┬а ┬а ┬а ┬а ┬а ┬а const currentTime = performance.now();
┬а ┬а ┬а ┬а ┬а ┬а const deltaTime = currentTime - lastTime;
┬а ┬а ┬а ┬а ┬а ┬а lastTime = currentTime;
┬а ┬а ┬а ┬а ┬а ┬а frameCount++;
┬а ┬а ┬а ┬а ┬а ┬а if (deltaTime > 1000) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а fps = frameCount;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а frameCount = 0;
┬а ┬а ┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('fps').textContent = fps;
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('renderTime').textContent = Math.round(deltaTime) + 'ms';
┬а ┬а ┬а ┬а ┬а ┬а document.getElementById('renderedNodes').textContent = renderer.info.render.calls;

┬а ┬а ┬а ┬а ┬а ┬а // Animate nodes
┬а ┬а ┬а ┬а ┬а ┬а networkNodes.forEach(node => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.rotation.x += node.userData.rotationSpeed;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.rotation.y += node.userData.rotationSpeed;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Pulse effect
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const pulseScale = 1 + Math.sin(currentTime * node.userData.pulseSpeed) * 0.1;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а node.scale.set(pulseScale, pulseScale, pulseScale);
┬а ┬а ┬а ┬а ┬а ┬а });

┬а ┬а ┬а ┬а ┬а ┬а // Animate data streams
┬а ┬а ┬а ┬а ┬а ┬а dataStreams.forEach(stream => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (showTraffic) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.userData.progress += stream.userData.speed * stream.userData.direction;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а if (stream.userData.progress >= 1 || stream.userData.progress <= 0) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.userData.progress = THREE.MathUtils.clamp(stream.userData.progress, 0, 1);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.userData.direction *= -1; // Reverse direction
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const p1 = stream.userData.connection.userData.node1.position;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const p2 = stream.userData.connection.userData.node2.position;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.position.lerpVectors(p1, p2, stream.userData.progress);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.visible = true;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а } else {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а stream.visible = false;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а }
┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а // Animate threat nodes
┬а ┬а ┬а ┬а ┬а ┬а if (showThreats) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threatNodes.forEach(threat => {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Simple hovering movement
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.x += Math.sin(currentTime * 0.001 + threat.userData.id) * 0.05;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.position.y += Math.cos(currentTime * 0.001 + threat.userData.id) * 0.05;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а // Pulsating glow
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а const pulseScale = 1 + Math.sin(currentTime * threat.userData.pulseSpeed) * 0.2;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.scale.set(pulseScale, pulseScale, pulseScale);
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а threat.material.emissiveIntensity = 0.5 + Math.sin(currentTime * 0.01) * 0.2;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а ┬а ┬а // Orbit camera around the scene
┬а ┬а ┬а ┬а ┬а ┬а if (!gsap.isTweening(camera.position)) {
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а camera.position.x = Math.sin(currentTime * 0.0001) * 500;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а camera.position.y = 200 + Math.sin(currentTime * 0.0002) * 50;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а camera.position.z = Math.cos(currentTime * 0.0001) * 500;
┬а ┬а ┬а ┬а ┬а ┬а ┬а ┬а camera.lookAt(new THREE.Vector3(0, 0, 0));
┬а ┬а ┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а ┬а ┬а renderer.render(scene, camera);
┬а ┬а ┬а ┬а }

┬а ┬а ┬а ┬а // Update HUD stats periodically
┬а ┬а ┬а ┬а setInterval(updateHUD, 2000);

┬а ┬а ┬а ┬а // Handle window resize
┬а ┬а ┬а ┬а window.addEventListener('resize', () => {
┬а ┬а ┬а ┬а ┬а ┬а camera.aspect = window.innerWidth / window.innerHeight;
┬а ┬а ┬а ┬а ┬а ┬а camera.updateProjectionMatrix();
┬а ┬а ┬а ┬а ┬а ┬а renderer.setSize(window.innerWidth, window.innerHeight);
┬а ┬а ┬а ┬а });
┬а ┬а ┬а ┬а┬а
┬а ┬а ┬а ┬а // Initial function call to start everything
┬а ┬а ┬а ┬а initUniverse();

┬а ┬а </script>
</body>
</html>